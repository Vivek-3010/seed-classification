# ml-server/server.py
from flask import Flask, request, jsonify
import tensorflow as tf
import numpy as np
from PIL import Image
import io
import cv2
from flask_cors import CORS



app = Flask(__name__)
CORS(app)

MODEL_PATH = "model.keras"
 # generated by train.py
IMG_SIZE = (224, 224)

# Class labels in same order as dataset folder sorting
CLASS_LABELS = ["Broken soybeans", "Immature soybeans", "Intact soybeans", "Skin-damaged soybeans", "Spotted soybeans"]

# Load model
model = tf.keras.models.load_model(MODEL_PATH)

def prepare_image(img_bytes):
    img = Image.open(io.BytesIO(img_bytes)).convert('RGB')
    img = img.resize(IMG_SIZE)
    arr = np.array(img).astype("float32")
    arr = tf.keras.applications.mobilenet_v2.preprocess_input(arr)
    arr = np.expand_dims(arr, axis=0)
    return arr

def simple_pest_and_hole_estimation(img_bytes):
    """
    Simple heuristic:
      - Convert to grayscale
      - Adaptive threshold to find small dark blobs (possible eggs)
      - Count small contours as pest_count
      - Count round larger holes as holes_detected
    NOTE: This is a heuristic for demo only.
    """
    arr = np.frombuffer(img_bytes, dtype=np.uint8)
    img = cv2.imdecode(arr, cv2.IMREAD_COLOR)
    if img is None:
        # fallback: return zeros
        return 0, 0
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    # small dark spots
    _, th = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    contours, _ = cv2.findContours(th, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    pest_count = 0
    holes = 0
    for c in contours:
        area = cv2.contourArea(c)
        if area < 8:  # noise
            continue
        if area < 50:
            pest_count += 1
        elif area < 1000:
            # medium shapes might be holes or damage
            holes += 1
        # else ignore very large areas
    return pest_count, holes

@app.route("/predict", methods=["POST"])
def predict():
    # Accept multiple fields named 'file' (backend sends them that way)
    files = request.files.getlist('file')
    if not files:
        files = request.files.getlist('images') or []
    if not files:
        return jsonify({"error": "no files provided"}), 400

    results = []
    damaged_count = 0
    total_pests = 0
    severity_dist = { "0":0, "1":0, "2":0, "3":0 }

    for idx, f in enumerate(files, start=1):
        img_bytes = f.read()
        x = prepare_image(img_bytes)
        preds = model.predict(x)
        ci = int(np.argmax(preds[0]))
        cls = CLASS_LABELS[ci]
        conf = float(preds[0][ci])

        # Severity mapping (customize as you like)
        severity_map = {
            "Intact soybeans": 0,
            "Immature soybeans": 1,
            "Broken soybeans": 2,
            "Spotted soybeans": 2,
            "Skin-damaged soybeans": 3
        }
        severity = int(severity_map.get(cls, 1))
        if severity > 0:
            damaged_count += 1

        pest_count, holes = simple_pest_and_hole_estimation(img_bytes)
        total_pests += pest_count

        severity_dist[str(severity)] = severity_dist.get(str(severity), 0) + 1

        results.append({
            "seed_id": idx,
            "filename": f.filename,
            "classification": cls,
            "confidence": conf,
            "severity": severity,
            "pest_count": pest_count,
            "holes_detected": holes
        })

    total = len(results)
    summary = {
        "total_seeds": total,
        "damaged_percentage": round(damaged_count / total * 100, 2),
        "avg_pest_count": round(total_pests / total, 2) if total>0 else 0,
        "severity_distribution": severity_dist
    }

    return jsonify({"results": results, "summary": summary})

if __name__ == "__main__":
    app.run(port=5001, debug=True)